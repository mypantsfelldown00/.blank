"""
Combined Stock Analysis & News App
- Yahoo Finance data with technical indicators
- Multiple forecasting models: Prophet, ARIMA, Random Forest, LSTM
- Real-time news feed from Google News RSS
- All in one powerful interface
"""

import warnings
warnings.filterwarnings("ignore")

import streamlit as st
import yfinance as yf
import pandas as pd
import numpy as np
import plotly.graph_objects as go
from plotly.subplots import make_subplots
from datetime import timedelta
import feedparser
import urllib.parse
import html
import re
import time
from datetime import datetime

# --------------------------
# ML libraries
# --------------------------
HAS_PROPHET = False
HAS_ARIMA = False
HAS_SKLEARN = False
HAS_TF = False

try:
    from prophet import Prophet
    HAS_PROPHET = True
except:
    Prophet = None

try:
    from statsmodels.tsa.arima.model import ARIMA
    HAS_ARIMA = True
except:
    ARIMA = None

try:
    from sklearn.ensemble import RandomForestRegressor
    from sklearn.preprocessing import MinMaxScaler
    HAS_SKLEARN = True
except:
    RandomForestRegressor = None
    MinMaxScaler = None

try:
    import tensorflow as tf
    from tensorflow import keras
    from tensorflow.keras import layers
    HAS_TF = True
except:
    tf = None
    keras = None
    layers = None

# --------------------------
# Streamlit page config + CSS
# --------------------------
st.set_page_config(page_title="POINT.BLANK", layout="wide")

st.markdown("""
<style>
:root{--bg:#000;--card:#0F0F10;--muted:#9E9E9E;--accent:#4DA6FF;--border:#2C2C2E;}
body, .stApp {background-color: #000000; color: #E6E6E6; font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', Roboto, sans-serif;}
.block-container {padding-top: 1.5rem; max-width: 1150px; margin-left:auto; margin-right:auto;}
.stButton>button {background-color: #1C1C1E; color: #E6E6E6; border-radius: 12px; border: 1px solid #2C2C2E; padding: 0.55em 1em;}
.stTextInput>div>div>input, .stSelectbox>div>div, .stSlider>div>div {background-color: #0F0F10; color: #E6E6E6; border-radius: 10px; border: 1px solid #222224;}
.stCheckbox>div, .stRadio>div {color: #E6E6E6;}
h1, h2, h3, h4 {color: #E6E6E6; text-align: center;}
.model-availability {background-color:#0B0B0C; padding:8px; border-radius:8px; border:1px solid #202022;}
.news-list {margin-top:10px;}
a.card-link { text-decoration:none; color:inherit; display:block; }
.news-card { background:var(--card); border:1px solid var(--border); border-radius:14px; padding:12px; margin-bottom:12px; display:flex; gap:14px; align-items:flex-start; transition: transform .06s ease, box-shadow .06s ease; }
.news-card:hover { transform: translateY(-4px); box-shadow: 0 6px 20px rgba(0,0,0,0.5); }
.news-img { width:120px; height:80px; object-fit:cover; border-radius:10px; flex-shrink:0; background:#050505; }
.news-content { flex:1; min-width:0; }
.news-title { font-weight:600; color:#E6E6E6; font-size:15px; line-height:1.3; margin-bottom:6px; overflow-wrap: anywhere; }
.news-meta { font-size:12px; color:var(--muted); }
.empty { color:var(--muted); padding:12px; border-radius:10px; background:#070707; border:1px solid #202022; }
</style>
""", unsafe_allow_html=True)

# --------------------------
# Disclaimer Gate
# --------------------------
st.markdown("## ️ DISCLAIMER")
st.markdown("""
Point blank provides stock market data, analysis, and predictive tools for **educational and informational purposes only**.  

- Point blank does **not** provide financial, investment, trading, or legal advice.  
- All information, forecasts, and analytics generated by Point blank are **estimates only** and may be inaccurate, incomplete, or outdated.  
- Stock market investments are inherently **risky and volatile**. Past performance is not indicative of future results.  
- Users are solely responsible for any investment or trading decisions made based on Point blank's content.  
- The developers, owners, affiliates, and contributors of Point blank shall **not be held liable** for any financial losses, damages, or consequences arising directly or indirectly from its use.  

By using Point blank, you acknowledge that you understand these risks and agree to use the website at your own discretion and responsibility.  
For personalized financial guidance, please consult a licensed financial advisor.
""")

accept = st.checkbox(" I have read and accept the disclaimer")

if not accept:
    st.warning("⚠️ Please accept the disclaimer to use the app.")
    st.stop()

# --------------------------
# Data & Analysis Utilities
# --------------------------
@st.cache_data(ttl=300)
def fetch_yahoo_data(ticker: str, period="6mo", interval="1d") -> pd.DataFrame:
    try:
        t = yf.Ticker(ticker)
        df = t.history(period=period, interval=interval)
        if df is None or df.empty:
            return pd.DataFrame()
        df = df.reset_index()
        df['Date'] = pd.to_datetime(df['Date'])
        try:
            df['Date'] = df['Date'].dt.tz_localize(None)
        except Exception:
            df['Date'] = pd.to_datetime(df['Date']).dt.tz_localize(None)
        for col in ['Open','High','Low','Close','Volume']:
            if col in df.columns:
                df[col] = pd.to_numeric(df[col], errors='coerce')
        df = df.dropna(subset=['Date','Close']).reset_index(drop=True)
        return df
    except Exception:
        return pd.DataFrame()

def compute_indicators(df: pd.DataFrame) -> pd.DataFrame:
    df = df.copy().reset_index(drop=True)
    df['MA20'] = df['Close'].rolling(20).mean()
    df['MA50'] = df['Close'].rolling(50).mean()
    df['EMA12'] = df['Close'].ewm(span=12, adjust=False).mean()
    df['EMA26'] = df['Close'].ewm(span=26, adjust=False).mean()
    df['MACD'] = df['EMA12'] - df['EMA26']
    df['Signal'] = df['MACD'].ewm(span=9, adjust=False).mean()
    df['BB_MID'] = df['Close'].rolling(20).mean()
    df['BB_STD'] = df['Close'].rolling(20).std(ddof=0).fillna(0)
    df['BB_UP'] = df['BB_MID'] + 2*df['BB_STD']
    df['BB_LOW'] = df['BB_MID'] - 2*df['BB_STD']
    delta = df['Close'].diff()
    up = delta.clip(lower=0)
    down = -delta.clip(upper=0)
    roll_up = up.rolling(14).mean()
    roll_down = down.rolling(14).mean()
    rs = roll_up / (roll_down + 1e-8)
    df['RSI'] = 100 - (100 / (1 + rs))
    df['RSI'] = df['RSI'].clip(0,100).fillna(50)
    return df

def plot_advanced(df: pd.DataFrame, title: str, show_indicators: bool = True):
    fig = make_subplots(rows=3, cols=1, shared_xaxes=True,
                        row_heights=[0.6,0.18,0.22],
                        vertical_spacing=0.03)
    fig.add_trace(go.Candlestick(x=df['Date'], open=df['Open'], high=df['High'],
                                 low=df['Low'], close=df['Close'], name='Price'), row=1, col=1)
    if show_indicators:
        fig.add_trace(go.Scatter(x=df['Date'], y=df['MA20'], name='MA20', line=dict(width=1.4)), row=1, col=1)
        fig.add_trace(go.Scatter(x=df['Date'], y=df['MA50'], name='MA50', line=dict(width=1.4, dash='dash')), row=1, col=1)
        fig.add_trace(go.Scatter(x=df['Date'], y=df['BB_UP'], name='BB_UP', line=dict(width=1, dash='dot')), row=1, col=1)
        fig.add_trace(go.Scatter(x=df['Date'], y=df['BB_LOW'], name='BB_LOW', line=dict(width=1, dash='dot')), row=1, col=1)
    fig.add_trace(go.Bar(x=df['Date'], y=df['Volume'], name='Volume', marker_color='gray', opacity=0.3), row=2, col=1)
    fig.add_trace(go.Scatter(x=df['Date'], y=df['RSI'], name='RSI', line=dict(width=1.2)), row=3, col=1)
    fig.add_hline(y=70, line_dash='dot', row=3, col=1)
    fig.add_hline(y=30, line_dash='dot', row=3, col=1)
    fig.update_layout(template='plotly_dark', title=title,
                      margin=dict(l=20,r=20,t=40,b=10),
                      paper_bgcolor='#000000', plot_bgcolor='#000000',
                      legend=dict(orientation='h', yanchor='bottom', y=1.02, xanchor='right', x=1))
    st.plotly_chart(fig, use_container_width=True, theme=None)

# --------------------------
# Forecasting Models
# --------------------------
def forecast_all(df: pd.DataFrame, periods: int = 30):
    forecasts = {}
    if HAS_PROPHET:
        try:
            prophet_df = df[['Date','Close']].rename(columns={'Date':'ds','Close':'y'}).copy()
            prophet_df['ds'] = pd.to_datetime(prophet_df['ds']).dt.tz_localize(None)
            m = Prophet(daily_seasonality=True, yearly_seasonality=True, weekly_seasonality=True)
            m.fit(prophet_df)
            future = m.make_future_dataframe(periods=periods, freq='D')
            future['ds'] = pd.to_datetime(future['ds']).dt.tz_localize(None)
            fc = m.predict(future)[['ds','yhat','yhat_lower','yhat_upper']].rename(columns={'ds':'Date'})
            forecasts['Prophet'] = fc
        except Exception as e:
            st.error(f"Prophet error: {e}")

    if HAS_ARIMA:
        try:
            series = df.set_index('Date')['Close'].sort_index()
            series.index = pd.to_datetime(series.index).tz_localize(None)
            daily_idx = pd.date_range(series.index.min(), series.index.max(), freq='D')
            series = series.reindex(daily_idx).ffill()
            model = ARIMA(series, order=(5,1,0)).fit()
            fc = model.forecast(steps=periods)
            dates = pd.date_range(start=series.index[-1]+timedelta(days=1), periods=periods)
            forecasts['ARIMA'] = pd.DataFrame({'Date': dates, 'yhat': fc.values})
        except Exception as e:
            st.error(f"ARIMA error: {e}")

    if HAS_SKLEARN:
        try:
            data = df[['Close']].copy()
            n_lags = 5
            for lag in range(1,n_lags+1):
                data[f'lag_{lag}'] = data['Close'].shift(lag)
            data = data.dropna()
            X = data[[f'lag_{i}' for i in range(1,n_lags+1)]].values
            y = data['Close'].values
            model = RandomForestRegressor(n_estimators=200, random_state=42)
            model.fit(X, y)
            last_window = X[-1].tolist()
            preds = []
            for _ in range(periods):
                p = float(model.predict([last_window]))
                preds.append(p)
                last_window = [p]+last_window[:-1]
            dates = pd.date_range(start=df['Date'].iloc[-1]+timedelta(days=1), periods=periods)
            forecasts['RandomForest'] = pd.DataFrame({'Date': dates, 'yhat': preds})
        except Exception as e:
            st.error(f"RandomForest error: {e}")

    if HAS_TF and HAS_SKLEARN:
        try:
            values = df['Close'].values.astype('float32')
            n_lags = 20
            scaler = MinMaxScaler()
            scaled = scaler.fit_transform(values.reshape(-1,1)).flatten()
            X, y = [], []
            for i in range(n_lags, len(scaled)):
                X.append(scaled[i-n_lags:i])
                y.append(scaled[i])
            X = np.array(X).reshape(-1, n_lags, 1)
            y = np.array(y)
            tf.keras.backend.clear_session()
            model = keras.Sequential([
                layers.Input(shape=(n_lags,1)),
                layers.LSTM(64, return_sequences=False),
                layers.Dense(32, activation='relu'),
                layers.Dense(1)
            ])
            model.compile(optimizer='adam', loss='mse')
            model.fit(X, y, epochs=10, batch_size=16, verbose=0)
            last_window = list(scaled[-n_lags:])
            preds_scaled = []
            for _ in range(periods):
                x = np.array(last_window).reshape(1, n_lags, 1)
                p = float(model.predict(x, verbose=0)[0,0])
                preds_scaled.append(p)
                last_window = last_window[1:]+[p]
            preds = scaler.inverse_transform(np.array(preds_scaled).reshape(-1,1)).flatten().tolist()
            dates = pd.date_range(start=df['Date'].iloc[-1]+timedelta(days=1), periods=periods)
            forecasts['LSTM'] = pd.DataFrame({'Date': dates, 'yhat': preds})
        except Exception as e:
            st.error(f"LSTM error: {e}")

    return forecasts

# --------------------------
# News Utilities
# --------------------------
@st.cache_data(ttl=360)
def get_company_name(ticker: str) -> str:
    if not ticker:
        return ""
    try:
        info = yf.Ticker(ticker).info
        return info.get("shortName") or info.get("longName") or ""
    except Exception:
        return ""

def _format_time(entry) -> str:
    try:
        if entry.get("published_parsed"):
            ts = time.mktime(entry.published_parsed)
            return datetime.fromtimestamp(ts).strftime("%a, %d %b %Y %H:%M:%S")
        if entry.get("published"):
            return str(entry.get("published"))
    except Exception:
        pass
    return "Unknown time"

def _extract_image(entry) -> str | None:
    # try common RSS fields
    mc = entry.get("media_content") or entry.get("mediaContents")
    if mc and isinstance(mc, (list, tuple)) and mc:
        first = mc[0]
        if isinstance(first, dict):
            url = first.get("url") or first.get("value")
            if url:
                return url
    mt = entry.get("media_thumbnail")
    if mt and isinstance(mt, (list, tuple)) and mt:
        try:
            return mt[0].get("url")
        except Exception:
            pass
    for l in entry.get("links", []):
        t = l.get("type", "")
        if t and t.startswith("image"):
            return l.get("href")
        if l.get("rel") == "enclosure" and l.get("href"):
            return l.get("href")
    # fallback: parse summary/description <img>
    summary = entry.get("summary", "") or entry.get("description", "")
    m = re.search(r'<img[^>]+src=["\']([^"\']+)["\']', summary or "", re.IGNORECASE)
    if m:
        return m.group(1)
    return None

def _resolve_link(entry, feed) -> str:
    # 1) prefer a non-news.google.com alternate link (links array)
    for l in entry.get("links", []):
        href = l.get("href") or ""
        rel = l.get("rel", "")
        typ = l.get("type", "")
        if href and "news.google.com" not in href and (rel == "alternate" or typ.startswith("text/html") or typ == ""):
            return href
    # 2) look in summary/description for first external href
    summary = entry.get("summary", "") or entry.get("description", "")
    m = re.search(r'href=["\'](https?://[^"\']+)["\']', summary or "", re.IGNORECASE)
    if m:
        href = m.group(1)
        if "news.google.com" not in href:
            return href
    # 3) try extracting 'url=' query param from entry.link (google redirect)
    link = entry.get("link", "") or ""
    if "url=" in link:
        qs = urllib.parse.parse_qs(urllib.parse.urlparse(link).query).get("url")
        if qs:
            candidate = qs[0]
            if candidate and "news.google.com" not in candidate:
                return candidate
    # 4) fallback: entry.link (may be Google News article)
    if link:
        return link
    # 5) feed-level link fallback
    return feed.feed.get("link") or ""

@st.cache_data(ttl=300)
def fetch_google_news(query: str, max_items: int = 8, hl: str = "en-US", gl: str = "US", ceid: str = "US:en"):
    if not query:
        return []
    encoded = urllib.parse.quote_plus(query)
    rss_url = f"https://news.google.com/rss/search?q={encoded}&hl={hl}&gl={gl}&ceid={ceid}"
    feed = feedparser.parse(rss_url)
    entries = feed.entries or []
    items = []
    seen = set()
    for entry in entries:
        try:
            title = html.unescape(entry.get("title", "")).strip() or "(no title)"
            published = _format_time(entry)
            # source
            src = ""
            s = entry.get("source")
            if isinstance(s, dict):
                src = s.get("title", "") or ""
            if not src:
                src = feed.feed.get("title", "") or entry.get("publisher", "") or "Unknown source"
            image = _extract_image(entry)
            link = _resolve_link(entry, feed)
            if not link:
                continue
            # dedupe by resolved link
            if link in seen:
                continue
            seen.add(link)
            items.append({
                "title": title,
                "link": link,
                "published": published,
                "source": src,
                "image": image
            })
            if len(items) >= max_items:
                break
        except Exception:
            continue
    return items

# --------------------------
# Main UI
# --------------------------
st.title("POINT.BLANK")
st.markdown("*Complete Stock Analysis & News Platform*")

tickers_list = [
    "AAPL","MSFT","GOOG","AMZN","TSLA","META","NVDA","JPM","V","JNJ","WMT",
    "RELIANCE.NS","TCS.NS","INFY.NS","HDFCBANK.NS","ICICIBANK.NS","SBIN.NS",
    "BTC-USD","ETH-USD"
]

controls = st.columns([2,2,2,2,1])
with controls[0]:
    ticker = st.selectbox("Ticker", tickers_list, index=0)
with controls[1]:
    period = st.selectbox("History period", ["1mo","3mo","6mo","1y","2y","5y","10y","max"], index=2)
with controls[2]:
    interval = st.selectbox("Interval", ["1d","1wk","1mo"], index=0)
with controls[3]:
    show_indicators = st.checkbox("Show Indicators", value=True)
with controls[4]:
    run = st.button(" Run All", type="primary")

st.markdown("---")

if run:
    # Fetch and process stock data
    with st.spinner("Fetching stock data and computing indicators..."):
        df = fetch_yahoo_data(ticker, period, interval)
    
    if df.empty:
        st.error("❌ No data retrieved. Check ticker or network connection.")
        st.stop()
    
    df = compute_indicators(df)

    # Display key metrics
    last = df.iloc[-1]
    metrics_cols = st.columns([1,1,1,1,1])
    with metrics_cols[0]: st.metric("Date", str(pd.to_datetime(last['Date']).date()))
    with metrics_cols[1]: st.metric("Open", f"${last['Open']:.2f}")
    with metrics_cols[2]: st.metric("High", f"${last['High']:.2f}")
    with metrics_cols[3]: st.metric("Low", f"${last['Low']:.2f}")
    with metrics_cols[4]: st.metric("Close", f"${last['Close']:.2f}")

    # Plot price chart with indicators
    st.subheader(" Price Chart & Technical Indicators")
    plot_advanced(df, f"{ticker} — Price & Indicators", show_indicators)

    # Create two columns for forecasts and news
    forecast_col, news_col = st.columns([1, 1])
    
    with forecast_col:
        st.subheader(" AI Forecasts")
        with st.spinner("Running forecasting models..."):
            forecasts = forecast_all(df, periods=30)
        
        if forecasts:
            for model_name, fc in forecasts.items():
                with st.expander(f" {model_name} Model", expanded=False):
                    st.dataframe(fc.head(10), use_container_width=True)
                    
                    # Plot forecast
                    fig = go.Figure()
                    fig.add_trace(go.Scatter(x=df['Date'].tail(50), y=df['Close'].tail(50), 
                                           name='Historical', line=dict(color='#E6E6E6')))
                    fig.add_trace(go.Scatter(x=fc['Date'], y=fc['yhat'], 
                                           name=f'{model_name} Forecast', line=dict(color='#4DA6FF')))
                    
                    if model_name == "Prophet" and 'yhat_lower' in fc.columns and 'yhat_upper' in fc.columns:
                        fig.add_trace(go.Scatter(x=fc['Date'], y=fc['yhat_lower'], 
                                               name='Lower Bound', line=dict(dash='dot', color='#666')))
                        fig.add_trace(go.Scatter(x=fc['Date'], y=fc['yhat_upper'], 
                                               name='Upper Bound', line=dict(dash='dot', color='#666')))
                    
                    fig.update_layout(template='plotly_dark', height=300,
                                    paper_bgcolor='#000000', plot_bgcolor='#000000')
                    st.plotly_chart(fig, use_container_width=True, theme=None)
                    
                    st.download_button(f"📥 Download {model_name} CSV", 
                                     fc.to_csv(index=False), 
                                     file_name=f"{ticker}_{model_name}.csv", 
                                     mime="text/csv",
                                     key=f"download_{model_name}")
        else:
            st.warning("⚠️ No forecasting models available. Install required libraries (prophet, statsmodels, sklearn, tensorflow).")

    with news_col:
        st.subheader(" NEWS")
        
        # Get company name for better news search
        company_name = get_company_name(ticker)
        
        # Build news query
        query = ticker or ""
        if company_name:
            query = f'{ticker} OR "{company_name}"'
        
        with st.spinner("Fetching latest news..."):
            articles = fetch_google_news(query, max_items=8, hl="en-US", gl="US", ceid="US:en")

        if not articles:
            st.markdown('<div class="empty"> No recent articles found.</div>', unsafe_allow_html=True)
        else:
            html_out = ['<div class="news-list">']
            for a in articles:
                # make safe values
                link = a["link"]
                title = html.escape(a["title"])
                src = html.escape(a["source"])
                pub = html.escape(a["published"])
                img = a.get("image")
                img_tag = ""
                if img:
                    img_url = img
                    if img_url.startswith("//"):
                        img_url = "https:" + img_url
                    if img_url.startswith("http://") or img_url.startswith("https://"):
                        img_tag = f'<img class="news-img" src="{html.escape(img_url, quote=True)}" loading="lazy" alt="thumb"/>'
                
                if img_tag:
                    card = f'''
<a class="card-link" href="{html.escape(link, quote=True)}" target="_blank" rel="noopener noreferrer">
  <div class="news-card">
    {img_tag}
    <div class="news-content">
      <div class="news-title">{title}</div>
      <div class="news-meta">{src} • {pub}</div>
    </div>
  </div>
</a>
'''
                else:
                    card = f'''
<a class="card-link" href="{html.escape(link, quote=True)}" target="_blank" rel="noopener noreferrer">
  <div class="news-card" style="align-items:center;">
    <div style="flex:1;">
      <div class="news-title">{title}</div>
      <div class="news-meta">{src} • {pub}</div>
    </div>
  </div>
</a>
'''
                html_out.append(card)
            html_out.append('</div>')
            st.markdown("".join(html_out), unsafe_allow_html=True)

    # Download raw data
    st.markdown("---")
    st.subheader(" Export Data")
    export_cols = st.columns([1,1,1])
    with export_cols[0]:
        st.download_button(" Download Raw Data (CSV)", 
                         df.to_csv(index=False), 
                         file_name=f"{ticker}_complete_data.csv", 
                         mime="text/csv")
    with export_cols[1]:
        st.download_button(" Download Historical Data (JSON)", 
                         df.to_json(orient='records', date_format='iso'), 
                         file_name=f"{ticker}_historical.json", 
                         mime="application/json")
    with export_cols[2]:
        if articles:
            news_df = pd.DataFrame(articles)
            st.download_button(" Download News Data (CSV)", 
                             news_df.to_csv(index=False), 
                             file_name=f"{ticker}_news.csv", 
                             mime="text/csv")

    # Recent data table
    st.markdown("---")
    st.subheader(" Recent Historical Data")
    st.dataframe(df.tail(20), use_container_width=True)

else:
    st.info(" Select a ticker and press **' Run'** to fetch comprehensive stock analysis with forecasts and news!")
    
    # Show model availability status
    st.markdown("###  Model Availability Status")
    status_cols = st.columns(4)
    with status_cols[0]:
        status = "✅ Available" if HAS_PROPHET else "❌ Missing"
        st.markdown(f"**Prophet:** {status}")
    with status_cols[1]:
        status = "✅ Available" if HAS_ARIMA else "❌ Missing"
        st.markdown(f"**ARIMA:** {status}")
    with status_cols[2]:
        status = "✅ Available" if HAS_SKLEARN else "❌ Missing"
        st.markdown(f"**Random Forest:** {status}")
    with status_cols[3]:
        status = "✅ Available" if HAS_TF else "❌ Missing"
        st.markdown(f"**LSTM:** {status}")

